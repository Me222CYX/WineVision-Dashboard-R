yprime <- y + xiTb0*exp(xiTb0) - exp(xiTb0)
X.QR <- qr(X)
Q1 <- qr.Q(X.QR)
U <- qr.R(X.QR)
beta <- backsolve(U, t(Q1)%*%yprime)
}
beta
sect6.nls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = c(beta0=.5, beta1=1, beta2=.5), data = lesions6)
sect6.nls
wts <- as.vector(exp(xiT%*%coef(sect6.nls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.nls), data = lesions6, weights=1/wts)
sect6.wls
tolerance <- e-7
tolerance <- 1e-7
tolerance <- 1e-7
prev.coeffs <- c(0,0,0)
while(max(abs(coef(sect6.wls) - prev.coeffs)) > tolerance){
prev.coeffs <- coef(sect6.wls)
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
}
sect6.wls
wts <- as.vector(exp(xiT%*%coef(sect6.nls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.nls), data = lesions6, weights=1/wts)
sect6.wls
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
sect6.wls
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
sect6.wls
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
sect6.wls
sect6.nls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = c(beta0=.5, beta1=1, beta2=.5), data = lesions6)
sect6.nls
wts <- as.vector(exp(xiT%*%coef(sect6.nls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.nls), data = lesions6, weights=1/wts)
sect6.wls
tolerance <- 1e-7
prev.coeffs <- c(0,0,0)
while(max(abs(coef(sect6.wls) - prev.coeffs)) > tolerance){
prev.coeffs <- coef(sect6.wls)
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
}
sect6.wls
l6.poisson <- glm(ACF.Total ~ T + INJ,
data = lesions6, family=poisson)
l6.poisson
library(MASS)
supressMessages(library(MASS))
suppressMessages(library(MASS))
suppressMessages(library(MASS))
qpoisson <- glm(ACF.Total ~ T + INJ + T:INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson)
suppressMessages(library(MASS))
nb <- glm.nb(ACF.Total ~ T + INJ + T:INJ,
data = lesions6)
summary(nb)
qpoisson <- glm(ACF.Total ~ T + INJ + T:INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson)
qpoisson <- glm(ACF.Total ~ T + INJ + T:INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson)
qpoisson <- glm(ACF.Total ~ T + INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson)
nb <- glm.nb(ACF.Total ~ T + INJ,
data = lesions6)
summary(nb)
nb.sim <- simulate(nb)$sim_1
sim <- simulate(nb)$sim_1
nb.sim <- glm.nb(sim ~ T + INJ,
data = lesions6)
summary(nb.sim)
valves <- p13.6
plot(valves)
?p13.6
valve.glm <- glm(numfail~months, family = poisson(link = "log"))
valve.glm <- glm(numfail~months,data = valves,  family = poisson(link = "log"))
plot(valves$numfail ~ valves$months , main = "Estimate of E[Y|X=x]")
a <- coef(valve.glm)[1]
b <- coef(valve.glm)[2]
curve(exp(a + b*x), add = TRUE)
valve.glm <- glm(numfail~months,data = valves,  family = poisson(link = "log"))
plot(valves$numfail ~ valves$months)
a <- coef(valve.glm)[1]
b <- coef(valve.glm)[2]
curve(exp(a + b*x), add = TRUE)
plot(valve.glm)
par(mfrow=c(2,2), mar=c(4, 4, 2, 1))
plot(valve.glm)
library(DAAG)
frogs
?frogs
library(DAAG)
head(frogs, 5)
plot(frogs)
frog.glm <- glm(pres.abs~ log(distance) + log(NoOfPools) + meanmin + meanmax,
data = frogs, family = "binomial")
summary(frog.glm)
frog.glm <- glm(pres.abs~ log(distance) + log(NoOfPools) + meanmin + meanmax,
data = frogs, family = binomial(link = "logit"))
summary(frog.glm)
par(mfrow=c(2,2), mar=c(4, 4, 2, 1))
plot(frog.glm)
coef(frog.glm)
coef(frog.glm)
a <- coef(frog.glm)[1]
b <- coef(frog.glm)[2]
c <- coef(frog.glm)[3]
d <- coef(frog.glm)[4]
e <- coef(frog.glm)[5]
simloglike <- function(x, y.glm, N=10) {
ll <- matrix(0, ncol=length(x), nrow=N)
for (j in 1:N) {
y <- simulate(y.glm)$sim_1
sim.glm <- glm(y Ëœ x, family = binomial)
simloglike <- function(x, y.glm, N=10) {
ll <- matrix(0, ncol=length(x), nrow=N)
for (j in 1:N) {
y <- simulate(y.glm)$sim_1
sim.glm <- glm(y ~ x, family = binomial)
a <- coef(sim.glm)[1]
b <- coef(sim.glm)[2]
loglikelihoodValues <- log(dpois(y, lambda =
exp(a + b*x)))
ll[j, ] <- loglikelihoodValues
}
ll <- data.frame(ll) #names(ll) <- as.character(x)
names(ll) <- ""
ll
}
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(AClike, ylim=range(c(llikelihoodValues,AClike)))
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,AClike)))
nrow(frogs)
y <- rbinom(nrow(frogs))
y <- rbinom(nrow(frogs), size = 1)
min(frogs$distance)
max(frogs$distance)
x1 <- runif(n, min = min(log(frogs$distance)))
x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
n <- 212
# Simulate values for predictors in range of data
x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
x2 <- runif(n, min = min(log(frogs$NoOfPools)), max = max(log(frogs$NoOfPools)))
x3 <- runif(n, min = min(frogs$meanmin), max = max(frogs$meanmin))
x4 <- runif(n, min = min(frogs$meanmax), max = max(frogs$meanmax))
# The relevant linear combination
combo <- a + b*x1 + c*x2 + d*x3 + e*x4
# Simulate y data using the logit
y <- rbinom(nrow(frogs), size = 1,
prob = exp(combo)/ (1+exp(combo)))
y
# llikelihoodValues <- with(frogs,
#   log(dpois(y, lambda = exp(a + b*x))))
set.seed(463)
n <- 212
# Simulate values for predictors in range of data
x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
x2 <- runif(n, min = min(log(frogs$NoOfPools)), max = max(log(frogs$NoOfPools)))
x3 <- runif(n, min = min(frogs$meanmin), max = max(frogs$meanmin))
x4 <- runif(n, min = min(frogs$meanmax), max = max(frogs$meanmax))
# The relevant linear combination
combo <- a + b*x1 + c*x2 + d*x3 + e*x4
# Simulate y data using the logit
y <- rbinom(nrow(frogs), size = 1,
prob = exp(combo)/ (1+exp(combo)))
y
# llikelihoodValues <- with(frogs,
#   log(dpois(y, lambda = exp(a + b*x))))
?dbinom
llikelihoodValues <- with(frogs,
log(dbinom(y, size = 1, prob = exp(combo)/ (1+exp(combo)))))
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,AClike)))
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,frogike)))
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,froglike)))
points(llikelihoodValues, pch=16, col=2)
llikelihoodValues
simulate(frog.glm)
simulate(frog.glm)$sim_1
# set.seed(463)
# n <- 212
# # Simulate values for predictors in range of data
# x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
# x2 <- runif(n, min = min(log(frogs$NoOfPools)), max = max(log(frogs$NoOfPools)))
# x3 <- runif(n, min = min(frogs$meanmin), max = max(frogs$meanmin))
# x4 <- runif(n, min = min(frogs$meanmax), max = max(frogs$meanmax))
# # The relevant linear combination
# combo <- a + b*x1 + c*x2 + d*x3 + e*x4
# # Simulate y data using the logit
# y <- rbinom(nrow(frogs), size = 1,
#             prob = exp(combo)/ (1+exp(combo)))
# y
x1 <- log(frogs$distance)
x1
combo <- a + b* log(frogs$distance) + c*log(frogs$NoOfPools) + d*frogs$meanmin + e* frogs$meanmax
# Get log likelihood values for simulated data
llikelihoodValues <- with(frogs,
log(dbinom(pres.abs, size = 1, prob = exp(combo)/ (1+exp(combo)))))
llikelihoodValues
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,froglike)))
points(llikelihoodValues, pch=16, col=2)
# Set up a simulation
set.seed(463)
n <- 212
# Simulate values for predictors in range of data
x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
x2 <- runif(n, min = min(log(frogs$NoOfPools)), max = max(log(frogs$NoOfPools)))
x3 <- runif(n, min = min(frogs$meanmin), max = max(frogs$meanmin))
x4 <- runif(n, min = min(frogs$meanmax), max = max(frogs$meanmax))
# The relevant linear combination
combo <- a + b*x1 + c*x2 + d*x3 + e*x4
# Simulate y data using the logit
y <- rbinom(nrow(frogs), size = 1,
prob = exp(combo)/ (1+exp(combo)))
y
simloglike <- function(x, y.glm, N=10) {
ll <- matrix(0, ncol=length(x), nrow=N)
for (j in 1:N) {
y <- simulate(y.glm)$sim_1
sim.glm <- glm(y ~ x, family = binomial)
a <- coef(sim.glm)[1]
b <- coef(sim.glm)[2]
c <- coef(sim.glm)[3]
d <- coef(sim.glm)[4]
e <- coef(sim.glm)[5]
loglikelihoodValues <- log(dbinom(pres.abs, size = 1, prob = exp(combo)/ (1+exp(combo))))
ll[j, ] <- loglikelihoodValues
}
ll <- data.frame(ll) #names(ll) <- as.character(x)
names(ll) <- ""
ll
}
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
froglike <- with(frogs, simloglike(frogs$pres.abs, frog.glm))
frogs$pres.abs
froglike <- simloglike(frogs$pres.abs, frog.glm)
froglike <- simloglike(frogs$pres.abs, frog.glm)
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(MPV))
lesions$T <- as.numeric(as.character(lesions$T) ) # T was a factor
xyplot(ACF.Total ~ T|INJ, data = subset(lesions, SECT==6))
lesions6 <- subset(lesions, SECT == 6)
lesions6
n <- nrow(lesions6)
xiT <- cbind(rep(1, n), lesions6$T, lesions6$INJ)
b0 <- c(.5, 1, .5)
X <- cbind(exp(xiT%*%b0), exp(xiT%*%b0), exp(xiT%*%b0))*xiT
#pseudodata
xiTb0 <- xiT%*%b0
y <- lesions6$ACF.Total
yprime <- y + xiTb0*exp(xiTb0) - exp(xiTb0)
#QR
X.QR <- qr(X)
Q1 <- qr.Q(X.QR)
U <- qr.R(X.QR)
beta <- backsolve(U, t(Q1)%*%yprime)
beta
tol <- 1e-7
while (max(abs(b0 - beta)) > tol) {
b0 <- beta
X <- cbind(exp(xiT%*%b0), exp(xiT%*%b0), exp(xiT%*%b0))*xiT
xiTb0 <- xiT%*%b0
yprime <- y + xiTb0*exp(xiTb0) - exp(xiTb0)
X.QR <- qr(X)
Q1 <- qr.Q(X.QR)
U <- qr.R(X.QR)
beta <- backsolve(U, t(Q1)%*%yprime)
}
beta
sect6.nls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = c(beta0=.5, beta1=1, beta2=.5), data = lesions6)
sect6.nls
wts <- as.vector(exp(xiT%*%coef(sect6.nls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.nls), data = lesions6, weights=1/wts)
sect6.wls
tolerance <- 1e-7
prev.coeffs <- c(0,0,0)
while(max(abs(coef(sect6.wls) - prev.coeffs)) > tolerance){
prev.coeffs <- coef(sect6.wls)
wts <- as.vector(exp(xiT%*%coef(sect6.wls)))
sect6.wls <- nls(y ~ exp(beta0 + beta1*T + beta2*INJ),
start = coef(sect6.wls), data = lesions6, weights=1/wts)
}
sect6.wls
l6.poisson <- glm(ACF.Total ~ T + INJ,
data = lesions6, family=poisson)
l6.poisson
qpoisson.interaction <- glm(ACF.Total ~ T + INJ + T:INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson.interaction)
suppressMessages(library(MASS))
nb.interaction <- glm.nb(ACF.Total ~ T + INJ + T:INJ,
data = lesions6)
summary(nb.interaction)
qpoisson <- glm(ACF.Total ~ T + INJ,
data = lesions6, family = quasipoisson)
summary(qpoisson)
nb <- glm.nb(ACF.Total ~ T + INJ,
data = lesions6)
summary(nb)
sim <- simulate(nb)$sim_1
nb.sim <- glm.nb(sim ~ T + INJ,
data = lesions6)
summary(nb.sim)
valves <- p13.6
plot(valves)
valve.glm <- glm(numfail~months,data = valves,  family = poisson(link = "log"))
plot(valves$numfail ~ valves$months)
a <- coef(valve.glm)[1]
b <- coef(valve.glm)[2]
curve(exp(a + b*x), add = TRUE)
par(mfrow=c(2,2), mar=c(4, 4, 2, 1))
plot(valve.glm)
library(DAAG)
head(frogs, 5)
plot(frogs)
frog.glm <- glm(pres.abs~ log(distance) + log(NoOfPools) + meanmin + meanmax,
data = frogs, family = binomial(link = "logit"))
summary(frog.glm)
par(mfrow=c(2,2), mar=c(4, 4, 2, 1))
plot(frog.glm)
coef(frog.glm)
a <- coef(frog.glm)[1]
b <- coef(frog.glm)[2]
c <- coef(frog.glm)[3]
d <- coef(frog.glm)[4]
e <- coef(frog.glm)[5]
# Get log likelihood values for real data
combo <- a + b* log(frogs$distance) + c*log(frogs$NoOfPools) + d*frogs$meanmin + e* frogs$meanmax
llikelihoodValues <- with(frogs,
log(dbinom(pres.abs, size = 1, prob = exp(combo)/ (1+exp(combo)))))
# Set up a simulation
set.seed(463)
n <- 212
# Simulate values for predictors in range of data
x1 <- runif(n, min = min(log(frogs$distance)), max = max(log(frogs$distance)))
x2 <- runif(n, min = min(log(frogs$NoOfPools)), max = max(log(frogs$NoOfPools)))
x3 <- runif(n, min = min(frogs$meanmin), max = max(frogs$meanmin))
x4 <- runif(n, min = min(frogs$meanmax), max = max(frogs$meanmax))
# The relevant linear combination
combo <- a + b*x1 + c*x2 + d*x3 + e*x4
# Simulate y data using the logit
y <- rbinom(nrow(frogs), size = 1,
prob = exp(combo)/ (1+exp(combo)))
y
simloglike <- function(x, y.glm, N=10) {
ll <- matrix(0, ncol=length(x), nrow=N)
for (j in 1:N) {
y <- simulate(y.glm)$sim_1
sim.glm <- glm(y ~ x, family = binomial)
a <- coef(sim.glm)[1]
b <- coef(sim.glm)[2]
c <- coef(sim.glm)[3]
d <- coef(sim.glm)[4]
e <- coef(sim.glm)[5]
loglikelihoodValues <- log(dbinom(pres.abs, size = 1, prob = exp(combo)/ (1+exp(combo))))
ll[j, ] <- loglikelihoodValues
}
ll <- data.frame(ll) #names(ll) <- as.character(x)
names(ll) <- ""
ll
}
froglike <- with(frogs, simloglike(pres.abs, frog.glm))
froglike <- with(frogs, simloglike(x, frog.glm))
simlike <- with(frogs, simloglike(y, frog.glm))
simloglike <- function(x, y.glm, N=10) {
ll <- matrix(0, ncol=length(x), nrow=N)
for (j in 1:N) {
y <- simulate(y.glm)$sim_1
sim.glm <- glm(y ~ x, family = binomial)
a <- coef(sim.glm)[1]
b <- coef(sim.glm)[2]
c <- coef(sim.glm)[3]
d <- coef(sim.glm)[4]
e <- coef(sim.glm)[5]
loglikelihoodValues <- log(dbinom(y, size = 1, prob = exp(combo)/ (1+exp(combo))))
ll[j, ] <- loglikelihoodValues
}
ll <- data.frame(ll) #names(ll) <- as.character(x)
names(ll) <- ""
ll
}
simlike <- with(frogs, simloglike(y, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,froglike)))
simlike <- with(frogs, simloglike(y, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(froglike, ylim=range(c(llikelihoodValues,simlike)))
simlike <- with(frogs, simloglike(y, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(simlike, ylim=range(c(llikelihoodValues,simlike)))
points(llikelihoodValues, pch=16, col=2)
set.seed(58319)
simlike <- with(frogs, simloglike(y, frog.glm))
par(mar=c(1, 4, .1,.1))
boxplot(simlike, ylim=range(c(llikelihoodValues,simlike)))
points(llikelihoodValues, pch=16, col=2)
source('~/Documents/Masters/block5/551/WineVision-R-group8/Eric2.R', echo=TRUE)
source('~/Documents/Masters/block5/551/WineVision-R-group8/minimal.R', echo=TRUE)
source('~/Documents/Masters/block5/551/WineVision-R-group8/minimal.R', echo=TRUE)
source('~/Documents/Masters/block5/551/dashr-heroku-deployment-demo/app.R', echo=TRUE)
source('~/Documents/Masters/block5/551/WineVision-R-group8/minimal.R', echo=TRUE)
source('~/Documents/Masters/block5/551/WineVision-R-group8/minimal.R', echo=TRUE)
source('~/Documents/Masters/block5/551/WineVision-R-group8/Eric.R', echo=TRUE)
library(ggplot2)
library(plotly)
library(plyr)
library(glue)
wine <- read.csv(file = "data/processed/wine_quality.csv")
factors <- c(1, 13, 14, 15)
#wine[, factors] <- as.factor(wine[, factors])
wine[, -factors] <- as.numeric(unlist(wine[, -factors]))
white <- wine[wine[,'Wine']=='white', ]
red <- wine[wine[,'Wine']=='red', ]
wine_type <- list('White' = white, 'Red' = red)
mu_white <- ddply(white, "Quality.Factor", numcolwise(mean))
mu_red <- ddply(red, "Quality.Factor",  numcolwise(mean))
mu_type <- list(mu_white, mu_red)
vars <- variable.names(wine)[-15] %>% as.vector()
vars
### OPERATION ###
density_plot <- function(winetype = 2, variable = 12) {
coln <- sym(colnames(wine)[variable])
ggplot(wine_type[[winetype]], aes(x = !!coln, fill = Quality.Factor)) +
geom_density(alpha = 0.4) +
geom_vline(data=mu_type[[winetype]], aes(xintercept=!!coln, color=Quality.Factor), linetype="dashed", size=0.9) +
ggtitle(glue('{coln} Quality Factor Distribution'), subtitle = glue('For {names(wine_type[winetype])} Wine')) +
theme_classic() +
theme(legend.title = element_text('Quality Levels'),
legend.position = c(0.94,0.88),
text = element_text(size = 12),
element_line(size = 0.3),
panel.grid.major = element_line(color = '#ededed')) +
ylab('Density') + xlab(coln)
}
wine %>% colnames %>% purrr::map(function(col) list(label = col, value = col))
wine %>% colnames %>% purrr::map(function(col) list(label = col, value = which(colnames(df)=="B")))
wine %>% colnames %>% purrr::map(function(col) list(label = col, value = which(colnames(wine)==col)))
test <- function(variable, winetype) {
coln <- sym(colnames(wine)[variable])
plot <- ggplot(wine_type[[winetype]], aes(x = !!coln, fill = Quality.Factor)) +
geom_density(alpha = 0.4) + ylab('Density') + xlab(coln) +
geom_vline(data=mu_type[[winetype]], aes(xintercept=!!coln, color=Quality.Factor), linetype="dashed", size=0.9) +
ggtitle(glue('{coln} Quality Factor Distribution'), subtitle = glue('For {names(wine_type[winetype])} Wine')) +
theme_classic() +
theme(legend.title = element_text('Quality Levels'),
legend.position = c(0.94,0.88),
text = element_text(size = 12),
element_line(size = 0.3),
panel.grid.major = element_line(color = '#ededed'))
return(ggplotly(plot))
}
test(3, 2)
test <- function(variable, winetype) {
coln <- sym(colnames(wine)[variable])
plot <- ggplot(wine_type[[winetype]], aes(x = !!coln, fill = Quality.Factor)) +
geom_density(alpha = 0.4) + ylab('Density') + xlab(coln) +
geom_vline(data=mu_type[[winetype]], aes(xintercept=!!coln, color=Quality.Factor), linetype="dashed", size=0.9) +
ggtitle(glue('{coln} Quality Factor Distribution'), subtitle = glue('For {names(wine_type[winetype])} Wine')) +
theme_classic() +
theme(legend.title = element_text('Quality Levels'),
legend.position = c(0.94,0.88),
text = element_text(size = 12),
element_line(size = 0.3),
panel.grid.major = element_line(color = '#ededed'))
return(ploe) #ggplotly(plot))
}
test(3, 2)
test <- function(variable, winetype) {
coln <- sym(colnames(wine)[variable])
plot <- ggplot(wine_type[[winetype]], aes(x = !!coln, fill = Quality.Factor)) +
geom_density(alpha = 0.4) + ylab('Density') + xlab(coln) +
geom_vline(data=mu_type[[winetype]], aes(xintercept=!!coln, color=Quality.Factor), linetype="dashed", size=0.9) +
ggtitle(glue('{coln} Quality Factor Distribution'), subtitle = glue('For {names(wine_type[winetype])} Wine')) +
theme_classic() +
theme(legend.title = element_text('Quality Levels'),
legend.position = c(0.94,0.88),
text = element_text(size = 12),
element_line(size = 0.3),
panel.grid.major = element_line(color = '#ededed'))
return(plot) #ggplotly(plot))
}
test(3, 2)
